<!DOCTYPE html>
<html>
<head>
    <title>Graph Coloring Visualization</title>
</head>
<body style="background-color:darkgray;">
    <h1 class="title">Graph Coloring Game</h1>
    <div style="display: flex;">
        <button style="margin-left: 17%; width: auto;" id="verifyButton">Check Answer</button>
        <button style="margin-left: 53%;" id="startButton">Start Algorithm</button>
        <button style="margin-left: 53%; display: none;" id="pauseButton">Pause Algorithm</button>
    </div>
    <div style="display: flex;">
        <canvas id="userCanvas"></canvas>
        <canvas id="algorithmCanvas"></canvas>
    </div>
    <style>

        #userCanvas {
            border: 0;
            display: flex;
            justify-content: flex-start;
        }

        #algorithmCanvas {
            border: 0;
            display: flex;
            justify-content: flex-end;
        }

        .title{
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 50px;
        }

    </style>

    <script>
        class Graph {
            constructor(vertices) {
                this.V = vertices;
                this.adj = [vertices];
                this.order = [vertices];

                for (let i = 0; i < vertices; i++){
                    this.adj[i] = [];
                    this.order[i] = [];
                }

                this.result = new Array(vertices).fill(-1);
            }

            addEdge(v, w) {
                this.adj[v].push(w);
                this.adj[w].push(v);
            }

            exists(v, w){
                for (const j of this.adj[v]){
                    if (j == w){
                        return true;
                    }
                }
                return false;
            }

            greedyColoring() {
                const available = new Array(this.V).fill(false);

                for (let v = 0; v < this.V; v++) {
                    for (const i of this.adj[v]) {
                        if (this.result[i] !== -1) {
                            available[this.result[i]] = true;
                        }
                    }

                    let color;

                    for (color = 0; color < this.V; color++) {
                        this.order[v].push(color);
                        vertextArray[v].coloring.push(nodeColors[color]);
                        if (!available[color]) {
                            break;
                        }
                    }

                    this.result[v] = color;
                    vertextArray[v].coloring.push(nodeColors[color]);

                    for (const i of this.adj[v]) {
                        if (this.result[i] !== -1) {
                            available[this.result[i]] = false;
                        }
                    }
                }
            }
        }

        class Vertex{
            constructor(posX, posY, color, radius){
                this.X = posX;
                this.Y = posY;
                this.color = color;
                this.radius = radius;
                this.user_color = 'white';
                this.color_counter = -1;
                this.coloring = [];
            }
        }

        const canvas = document.getElementById('userCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 600;
        canvas.height = 600;
        const canvas2 = document.getElementById('algorithmCanvas');
        const ctx2 = canvas2.getContext('2d');
        canvas2.width = 600;
        canvas2.height = 600;

        const nodeRadius = 20;
        const nodeColors = ['red', 'green', 'blue', 'orange', 'purple', 'yellow', 'pink', 'brown', 'lightblue', 'violet', 'white'];
        
        const vertextArray = [];
        const size = Math.floor(Math.random() * (10 - 5 + 1)) + 5;
        const g = new Graph(size); 

        let vertex_counter = 0;
        let frame = 0;
        const framePerNode = 60;
        let color_index = -1;

        const startButton = document.getElementById("startButton");
        const pauseButton = document.getElementById("pauseButton");
        const checkButton = document.getElementById("verifyButton");
        let isPaused = false;
        let isDone = false;

        function drawNode() {
            ctx.clearRect(0,0,canvas.width, canvas.height);

            drawEdgesUser();

            for (let i = 0; i < g.V; i++){
                ctx.beginPath();
                ctx.arc(vertextArray[i].X, vertextArray[i].Y , nodeRadius, 0, 2 * Math.PI);
                ctx.fillStyle = vertextArray[i].user_color;
                ctx.fill();
                ctx.stroke();
            }
        }

        function drawAlgoNode(){
            ctx2.clearRect(0,0,canvas2.width, canvas2.height);

            drawEdgesAnimation();
            
            for (let i = 0; i < g.V; i++){
                ctx2.beginPath();
                ctx2.arc(vertextArray[i].X, vertextArray[i].Y, nodeRadius, 0, 2 * Math.PI);
                ctx2.fillStyle = vertextArray[i].color;
                ctx2.fill();
                ctx2.stroke();
            }
        }

        function animate(){

            function paused(){
                if (isPaused){
                    setTimeout(function (){}, 1000)
                    paused();
                }
            }

            if (isPaused){
                paused();
            }

            if (vertex_counter >= g.V){

                color_index = -1;
                vertex_counter = 0;
                frame = 0;
                pauseButton.click();

                for (let i = 0; i < g.V; i++) {
                    vertextArray[i].color = 'white';
                }

                return;
            }


            if (color_index < vertextArray[vertex_counter].coloring.length - 1){
                frame++;

                if (frame >= framePerNode){
                    frame = 0;
                    color_index++;
                    vertextArray[vertex_counter].color = vertextArray[vertex_counter].coloring[color_index];
                }

                drawAlgoNode();
                requestAnimationFrame(animate);
            }
            else{
                color_index = -1;
                vertex_counter++;

                drawAlgoNode();
                requestAnimationFrame(animate);
            }
            
        }

        function drawEdgesUser() {
            for (let v = 0; v < g.V; v++) {
                const x1 = vertextArray[v].X;
                const y1 = vertextArray[v].Y;

                for (const w of g.adj[v]) {
                    if (w < v){
                        const x2 = vertextArray[w].X;
                        const y2 = vertextArray[w].Y;

                        ctx.beginPath();
                        ctx.moveTo(x1, y1);
                        ctx.lineTo(x2, y2);
                        ctx.stroke();
                    }
                }
            }
        }

        function drawEdgesAnimation() {
            for (let v = 0; v < g.V; v++) {
                const x1 = vertextArray[v].X;
                const y1 = vertextArray[v].Y;

                for (const w of g.adj[v]) {
                    if (w < v){
                        const x2 = vertextArray[w].X;
                        const y2 = vertextArray[w].Y;

                        ctx2.beginPath();
                        ctx2.moveTo(x1, y1);
                        ctx2.lineTo(x2, y2);
                        ctx2.stroke();
                    }
                }
            }
        }

        function getNodeAtCoordinates(x, y) {
            return vertextArray.find(node => {
                const distance = Math.sqrt((node.X - x) ** 2 + (node.Y - y) ** 2);
                return distance <= nodeRadius;
            });
        }

        function resizeCanvas() {
            const size = Math.min(window.innerHeight, window.innerWidth);
            const containerWidth = canvas.parentElement.clientWidth;
            const containerHeight = window.innerHeight;


            ctx.clearRect(0,0,canvas.width, canvas.height);
            ctx2.clearRect(0,0,canvas2.width, canvas2.height);


            canvas.width = containerWidth/2.5;
            canvas.height = containerWidth/2.5;
            canvas2.width = containerWidth/2.5;
            canvas2.height = containerWidth/2.5;

            for (let i = 0; i < g.V; i++) {
                vertextArray[i].X = (canvas.width / 2) + canvas.width/2.5 * Math.cos((i/g.V) * 2 * Math.PI);
                vertextArray[i].Y = (canvas.width / 2) + canvas.width/2.5 * Math.sin((i/g.V) * 2 * Math.PI);
            }

            drawNode();
            drawAlgoNode();
        }

        for (let i = 0; i < g.V; i++){
            for (let j = 0; j < g.V; j++){
                if (i != j && !g.exists(i,j)){
                    if (g.adj[j].length > 1){
                        if (Math.random() < 0.05){
                            g.addEdge(i,j);
                        }
                    }
                    else if (Math.random() < 0.3){
                        g.addEdge(i,j);
                    }
                }
            }
        }

        for (let v = 0; v < g.V; v++) {
            let posX = (canvas.width / 2) + 200 * Math.cos((v/g.V) * 2 * Math.PI);
            let posY = (canvas.width / 2) + 200 * Math.sin((v/g.V) * 2 * Math.PI);
            vertextArray.push(new Vertex(posX, posY, 'white', nodeRadius));
        }

        canvas.addEventListener("click", function(event) {
            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;
            const clickedNode = getNodeAtCoordinates(mouseX, mouseY);

            if (clickedNode) {
                clickedNode.color_counter += 1;
                clickedNode.color_counter %= g.V;
                clickedNode.user_color = nodeColors[clickedNode.color_counter];
                drawNode();
            }
        });

        startButton.addEventListener("click", async function() {
            isPaused = false;
            startButton.disabled = true;
            pauseButton.style.display = 'inline';
            startButton.style.display = 'none';

            if (!isPaused){
                animate();
            }
        });

        pauseButton.addEventListener("click", async function() {
            isPaused = true;
            startButton.disabled = false;
            pauseButton.style.display = 'none';
            startButton.style.display = 'inline';
        });

        checkButton.addEventListener("click", async function() {
            for (let i = 0; i < g.V; i++){
                console.log(vertextArray[i].user_color);
            }
        });

        window.addEventListener("resize", resizeCanvas);

        g.greedyColoring();
        resizeCanvas();
        drawNode();
        drawAlgoNode();

    </script>
</body>
</html>